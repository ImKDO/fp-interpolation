# Отчёт по проекту «fp-interpolation»

## Титульный лист
- **ФИО:** Кравченко Дмитрий Олегович
- **Группа:** P3319
- **ИСУ:** 408891

## Требования к разработанному ПО
1. **Формат входных данных:** поток строк `x y`, разделённых пробелами, запятыми, точками с запятой или табами. Пустые строки игнорируются; некорректные — отклоняются с сообщением об ошибке.
2. **Алгоритмы интерполяции:**
   - `linear` — кусочно-линейная интерполяция двух последних точек.
   - `newton:k` — интерполяция k-точечным полиномом Ньютона с разделёнными разностями.
3. **Параметры запуска:**
   - `--methods` / `-m` — список алгоритмов через запятую (по умолчанию `linear`).
   - `--step` / `-s` — шаг дискретизации результата (> 0, по умолчанию `1.0`).
4. **Потоковая обработка:** новые точки проверяются на упорядоченность по `x`, накапливаются во «скользящих окнах», после чего интерполятор выдаёт равномерно распределённые точки между крайними `x`.
5. **Ошибки:** нарушение формата, попытка использовать дублирующиеся `x`, отрицательный шаг и неупорядоченные точки приводят к немедленному завершению с поясняющим сообщением.


## Ключевые элементы реализации

- **`Methods.Dataset`** — нормализация разделителей, разбор строк в точки, проверка монотонности входного набора.  

```fp-interpolation/lib/methods.ml#L35-57
  let parse_line line =
    match tokens line with
    | [] -> None
    | [ sx; sy ] ->
        (try
           let x = float_of_string sx in
           let y = float_of_string sy in
           Some { x; y }
         with Failure _ ->
           raise (Parse_error (Printf.sprintf "Неверные числа: %S" line)))
    | _ ->
        raise
          (Parse_error
             (Printf.sprintf "Ожидалось две колонки (x y), получено: %S" line))
```

- **`Methods.Algorithm`** — описания алгоритмов (имя, арность, функция вычисления) и фабрика для их запуска; поддержка `Linear` и `Newton n`.

- **`Methods.Sliding_window`** — ограниченное окно последних точек с операциями `push`, `take_last`, `last_exn`, позволяющее подготавливать массивы нужной длины под конкретный алгоритм.

- **`Methods.Runner`** — состояние исполнения (текущий курсор, шаг, окно); функции `feed` и `flush` генерируют равномерные точки между последними узлами, используя выбранный алгоритм.

- **`lib/io.ml`** — CLI-интерфейс: парсинг аргументов, построение набора раннеров (по алгоритму на каждый метод), чтение `stdin`, проверка и передача точек, вывод результатов.  

```fp-interpolation/lib/io.ml#L41-90
let parse_args () =
  let methods_arg = ref None in
  let step_arg = ref None in
  let usage =
    "Использование: fp-interpolation [--methods linear,newton:4] [--step 0.5]"
  in
  let set_methods s = methods_arg := Some (parse_methods s) in
  let set_step s = step_arg := Some (parse_step s) in
  let speclist =
    [ ("--methods", Arg.String set_methods, "Методы через запятую (linear,newton:k)")
    ; ("-m", Arg.String set_methods, "Синоним --methods")
    ; ("--step", Arg.String set_step, "Шаг дискретизации результатов (> 0)")
    ; ("-s", Arg.String set_step, "Синоним --step")
    ]
  in
  let anon arg =
    raise
      (Arg.Bad (Printf.sprintf "Неизвестный позиционный аргумент: %S" arg))
  in
  Arg.parse speclist anon usage;
  let methods =
    match !methods_arg with
    | Some ms -> ms
    | None -> default_config.methods
  in
  let step =
    match !step_arg with
    | Some s -> s
    | None -> default_config.step
  in
  { methods; step }
```

- **`test/test_fp_interpolation.ml`** — набор из 7 тестов на Alcotest: корректность парсинга, проверка упорядоченности, значения интерполяции, потоковая генерация точек.


## Ввод/вывод программы
1. **Запуск:**  
   ```/dev/null/io.txt#L1-1
   fp-interpolation --methods linear,newton:3 --step 0.25 < data.txt
   ```
2. **Вход:**  
   ```/dev/null/io.txt#L3-5
   0 0
   1 1
   2 4
   ```
3. **Вывод:** строки вида `<алгоритм>: <x> <y>` с десятичной точкой и фиксированной точностью, например:  
   ```/dev/null/io.txt#L7-10
   linear: 0 0
   linear: 0.25 0.25
   ...
   newton[3]: 1.5 2.25
   ```
4. **Завершение:** при успешной обработке процесс заканчивается после достижения EOF и сброса накопленных точек. При ошибках — вывод на stderr и код выхода `1` или `2`, в зависимости от источника.

## Выводы
- Использование модульной структуры (Dataset/Algorithm/Runner) облегчает расширение — добавление нового метода требует лишь новой спецификации в `Algorithm`.
- Скользящее окно позволяет писать потоковый код без лишних копий и держать ровно столько данных, сколько нужно алгоритму.
- Применение Alcotest упрощает поддержку: тесты декларируют поведение парсера, расчётов и стриминга, что ускоряет регрессионную проверку.
- Потоковая модель ввода/вывода с немедленной валидацией (ранний выход при ошибках) повышает устойчивость и делает программу подходящей для unix-конвейеров.